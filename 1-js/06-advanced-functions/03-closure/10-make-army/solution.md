
لنُجري مسحًا شاملًا على ما يجري في `‎makeArmy‎`، حينها سيظهر لنا الحل جليًا.

1. تُنشئ مصفوفة `‎shooters‎` فارغة:

    ```js
    let shooters = [];
    ```
. تملأ المصفوفة في حلقة عبر `‎shooters.push(function...)‎`.

    كلّ عنصر هو دالة، بهذا تكون المصفوفة الناتجة هكذا:


    ```js no-beautify
    shooters = [
      function () { alert(i); },
      function () { alert(i); },
      function () { alert(i); },
      function () { alert(i); },
      function () { alert(i); },
      function () { alert(i); },
      function () { alert(i); },
      function () { alert(i); },
      function () { alert(i); },
      function () { alert(i); }
    ];
    ```

3. تُعيد الدالة المصفوفة.

لاحقًا، يستلم استدعاء `‎army[5]()‎` العنصر `‎army[5]‎` من المصفوفة، وهي دالة فيستدعيها.

الآن، لماذا تعرض كلّ هذه الدوال نفس الناتج؟

يعود ذلك إلى عدم وجود أيّ متغير محلي باسم `‎i‎` في دوال `‎shooter‎`. فحين تُستدعى هذه الدالة تأخذ المتغير `‎i‎` من البيئة المُعجمية الخارجية.

وماذا ستكون قيمة `‎i‎`؟

لو رأينا مصدر القيمة:


```js
function makeArmy() {
  ...
  let i = 0;
  while (i < 10) {
    let shooter = function() { // shooter function
      alert( i ); // should show its number
    };
    ...
  }
  ...
}
```
كما نرى... «تعيش» القيمة في البيئة المُعجمية المرتبطة بدورة `‎makeArmy()‎` الحالية. ولكن متى استدعينا `‎army[5]()‎`، تكون دالة `‎makeArmy‎` قد أنهت مهمّتها فعلًا وقيمة `‎i‎` هي آخر قيمة، أي `‎10‎` (قيمة نهاية حلقة `‎while‎`).

وبهذا تأخذ كلّ دوال `‎shooter‎` القيمة من البيئة المُعجمية الخارجية، ذات القيمة الأخيرة `‎i=10‎`.

يمكن أن نُصلح ذلك بنقل تعريف المتغير إلى داخل الحلقة:


```js run demo
function makeArmy() {

  let shooters = [];

*!*
  for(let i = 0; i < 10; i++) {
*/!*
    let shooter = function() { // دالة مُطلق النار
      alert( i );  // المفترض أن ترينا رقمها
    };
    shooters.push(shooter);
  }

  return shooters;
}

let army = makeArmy();

army[0](); // 0
army[5](); // 5
```

الآن صارت تعمل كما يجب، إذ في كلّ مرة تُنفّذ كتلة الشيفرة في `‎for (let i=0...) {...}‎`، يُنشئ المحرّك بيئة مُعجمية جديدة لها فيها متغير `‎i‎` المناسب لتلك الكتلة.

إذًا لنلخّص: قيمة `‎i‎` صارت «تعيش» أقرب للدالة من السابق. لم تعد في بيئة `‎makeArmy()‎` المُعجمية بل الآن في تلك البيئة المخصّصة لدورة الحلقة الحالية. هكذا صارت تعمل كما يجب.


![](lexenv-makearmy.svg)

أعدنا كتابة الشيفرة هنا وعوّضنا `‎while‎` بحلقة `‎for‎`.

يمكننا أيضًا تنفيذ حيلة أخرى. لنراها لفهم الموضوع أكثر:


```js run
function makeArmy() {
  let shooters = [];

  let i = 0;
  while (i < 10) {
*!*
    let j = i;
*/!*
    let shooter = function() { // دالة مُطلق النار
      alert( *!*j*/!* ); // (*) المفترض أن ترينا رقمها
    };
    shooters.push(shooter);
    i++;
  }

  return shooters;
}

let army = makeArmy();

army[0](); // 0
army[5](); // 5
```

كما حلقة `‎for‎`، فحلقة `‎while‎` تصنع بيئة مُعجمية جديدة لكلّ دورة، وهكذا نتأكّد بأن تكون قيمة `‎shooter‎` صحيحة.

باختصار ننسخ القيمة `‎let j = i‎` وهذا يصنع المتغير `‎j‎` المحلي داخل الحلقة وينسخ قيمة `‎i‎` إلى نفسه. تُنسخ الأنواع الأولية «حسب قيمتها» _By value_، لذا بهذا نأخذ نسخة كاملة مستقلة تمامًا عن `‎i‎`، ولكنّها مرتبطة بالدورة الحالية في الحلقة.

